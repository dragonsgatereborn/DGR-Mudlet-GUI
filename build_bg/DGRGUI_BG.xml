<?xml version='1.0' encoding='utf-8'?>
<MudletPackage version="1.001">
  <ScriptPackage>
<Script isActive="yes" isFolder="no">
      <name>DGRGUI Background</name>
      <script>-- DGR background using label + stylesheet.

dgrgui_bg = dgrgui_bg or {debug = true, enabled = true, logBuffer = {}, consoleRect = {x = 0, y = 0, w = 1500, h = 900}}

local logToFile

local function dbg(msg)
  if dgrgui_bg.debug then
    cecho("&lt;green&gt;DGRGUI_BG: &lt;reset&gt;" .. tostring(msg or "") .. "\n")
  end
  local ok, err = pcall(logToFile, msg)
  if not ok then
    cecho("&lt;red&gt;DGRGUI_BG: &lt;reset&gt;logToFile error: " .. tostring(err) .. "\n")
  end
end
logToFile = function(msg)
  local line = os.date("%Y-%m-%d %H:%M:%S") .. " " .. tostring(msg or "") .. "\n"
  dgrgui_bg.logBuffer = dgrgui_bg.logBuffer or {}
  local okInsert = pcall(table.insert, dgrgui_bg.logBuffer, line)
  if not okInsert then
    cecho("&lt;red&gt;DGRGUI_BG: &lt;reset&gt;logBuffer insert failed\n")
  end

  local home = getMudletHomeDir and getMudletHomeDir() or ""
  if home == "" or home == nil then
    home = os.getenv("HOME") or "/tmp"
  end
  home = tostring(home):gsub("\\", "/")
  local dir = home .. "/DGRGUI_BG"
  local primary = dir .. "/debug.log"
  local fallback = "/tmp/DGRGUI_BG_debug.log"

  if lfs and lfs.mkdir and not (lfs.attributes and lfs.attributes(dir)) then
    pcall(lfs.mkdir, dir)
  end

  local ok, fh = pcall(io.open, primary, "a")
  if ok and fh then
    fh:write(line)
    fh:close()
    dgrgui_bg.lastLogPath = primary
    return true, primary
  end

  local ok2, fh2 = pcall(io.open, fallback, "a")
  if ok2 and fh2 then
    fh2:write(line)
    fh2:close()
    cecho("&lt;red&gt;DGRGUI_BG: &lt;reset&gt;Log fallback in use: " .. fallback .. "\n")
    dgrgui_bg.lastLogPath = fallback
    return true, fallback
  end

  cecho("&lt;red&gt;DGRGUI_BG: &lt;reset&gt;Unable to write any debug log (buffering)\n")
  dgrgui_bg.lastLogPath = "buffer"
  return false, "buffer"
end

local function packageDir()
  local home = getMudletHomeDir():gsub("\\", "/")
  local dgr = home .. "/DGRGUI_BG"
  local emco = home .. "/EMCOChat"
  if io.exists(dgr .. "/border_top.png") then
    return dgr
  end
  if io.exists(emco .. "/border_top.png") then
    return emco
  end
  return dgr
end

local function ensureAssets()
  local home = getMudletHomeDir():gsub("\\", "/")
  local dgr = home .. "/DGRGUI_BG"
  local emco = home .. "/EMCOChat"
  if lfs and lfs.mkdir and not (lfs.attributes and lfs.attributes(dgr)) then
    pcall(lfs.mkdir, dgr)
  end
  local function copyIfMissing(name)
    local dst = dgr .. "/" .. name
    if io.exists(dst) then
      return true
    end
    local src = emco .. "/" .. name
    if not io.exists(src) then
      return false
    end
    local okIn, fin = pcall(io.open, src, "rb")
    if not okIn or not fin then
      return false
    end
    local data = fin:read("*a")
    fin:close()
    local okOut, fout = pcall(io.open, dst, "wb")
    if not okOut or not fout then
      return false
    end
    fout:write(data or "")
    fout:close()
    return true
  end
  local copied = {}
  for _, name in ipairs({
    "border_top.png",
    "border_bottom.png",
    "border_left.png",
    "border_right.png",
    "dgr_image.png",
    "emco.lua",
    "loggingconsole.lua",
    "demontools.lua",
    "config.lua",
    "computer.png",
  }) do
    if copyIfMissing(name) then
      copied[#copied + 1] = name
    end
  end
  if #copied > 0 then
    dbg("ensureAssets: copied -> " .. table.concat(copied, ", "))
    logToFile("ensureAssets: copied -> " .. table.concat(copied, ", "))
  end
end

dgrgui_bg.ensureAssets = ensureAssets
dgrgui_bg.packageDir = packageDir
_G.ensureAssets = ensureAssets
_G.packageDir = packageDir

local function borderPath(name)
  return packageDir() .. "/" .. name
end

function dgrgui_bg.dumpState()
  dbg("state: enabled=" .. tostring(dgrgui_bg.enabled) .. " debug=" .. tostring(dgrgui_bg.debug))
  logToFile("state: enabled=" .. tostring(dgrgui_bg.enabled) .. " debug=" .. tostring(dgrgui_bg.debug))
  local rect = dgrgui_bg.consoleRect or {}
  dbg("state: consoleRect=" .. tostring(rect.x) .. "," .. tostring(rect.y) .. " " .. tostring(rect.w or rect.width) .. "x" .. tostring(rect.h or rect.height))
  logToFile("state: consoleRect=" .. tostring(rect.x) .. "," .. tostring(rect.y) .. " " .. tostring(rect.w or rect.width) .. "x" .. tostring(rect.h or rect.height))
end

function dgrgui_bg.setConsoleRect(x, y, w, h)
  dgrgui_bg.consoleRect = {x = x, y = y, w = w, h = h}
  dbg("setConsoleRect: " .. x .. "," .. y .. " " .. w .. "x" .. h)
  logToFile("setConsoleRect: " .. x .. "," .. y .. " " .. w .. "x" .. h)
end

function dgrgui_bg.logPath()
  local home = getMudletHomeDir():gsub("\\", "/")
  local dir = home .. "/DGRGUI_BG"
  local primary = dir .. "/debug.log"
  dbg("logPath: " .. primary)
  logToFile("logPath: " .. primary)
end

function dgrgui_bg.forceLogWrite()
  local ok, path = logToFile("forceLogWrite: ping")
  cecho("&lt;green&gt;DGRGUI_BG: &lt;reset&gt;forceLogWrite ok=" .. tostring(ok) .. " path=" .. tostring(path) .. "\n")
end

function dgrgui_bg.logStatus()
  local path = dgrgui_bg.lastLogPath or "none"
  cecho("&lt;green&gt;DGRGUI_BG: &lt;reset&gt;lastLogPath=" .. tostring(path) .. "\n")
end

function dgrgui_bg.printLog()
  dgrgui_bg.logBuffer = dgrgui_bg.logBuffer or {}
  cecho("&lt;green&gt;DGRGUI_BG: &lt;reset&gt;logBuffer entries=" .. tostring(#dgrgui_bg.logBuffer) .. "\n")
  for i, line in ipairs(dgrgui_bg.logBuffer) do
    cecho("&lt;green&gt;DGRGUI_BG: &lt;reset&gt;" .. line)
  end
end

function dgrgui_bg.writeLog(path)
  dgrgui_bg.logBuffer = dgrgui_bg.logBuffer or {}
  local ok, fh = pcall(io.open, path, "a")
  if ok and fh then
    for _, line in ipairs(dgrgui_bg.logBuffer) do
      fh:write(line)
    end
    fh:close()
    cecho("&lt;green&gt;DGRGUI_BG: &lt;reset&gt;writeLog ok: " .. path .. "\n")
  else
    cecho("&lt;red&gt;DGRGUI_BG: &lt;reset&gt;writeLog failed: " .. tostring(path) .. "\n")
  end
end

function dgrgui_bg.testWrite()
  local home = getMudletHomeDir():gsub("\\", "/")
  local dir = home .. "/DGRGUI_BG"
  local testPath = dir .. "/test_write.txt"
  local ok, fh = pcall(io.open, testPath, "a")
  if ok and fh then
    fh:write(os.date("%Y-%m-%d %H:%M:%S") .. " test_write\n")
    fh:close()
    cecho("&lt;green&gt;DGRGUI_BG: &lt;reset&gt;test_write OK: " .. testPath .. "\n")
  else
    cecho("&lt;red&gt;DGRGUI_BG: &lt;reset&gt;test_write FAILED: " .. testPath .. "\n")
  end
end

function dgrgui_bg.apply()
  dbg("apply: start")
  local okLog, pathLog = logToFile("apply: start")
  if not okLog then
    cecho("&lt;red&gt;DGRGUI_BG: &lt;reset&gt;apply: logToFile failed\n")
  else
    cecho("&lt;green&gt;DGRGUI_BG: &lt;reset&gt;apply: logToFile ok -> " .. tostring(pathLog) .. "\n")
  end
  if not dgrgui_bg.enabled then
    dbg("apply: disabled, hiding label")
    logToFile("apply: disabled, hiding label")
    if dgrgui_bg.label then
      dgrgui_bg.label:hide()
    end
    return
  end
  if not Geyser or not Geyser.Label then
    cecho("&lt;red&gt;DGRGUI_BG: &lt;reset&gt;Geyser.Label not available\n")
    logToFile("Geyser.Label not available")
    return
  end
  dbg("apply: Geyser.Label ok")
  logToFile("apply: Geyser.Label ok")

  if type(setBgColor) == "function" then
    setBgColor("main", 0, 0, 0, 255)
    dbg("apply: setBgColor main")
    logToFile("apply: setBgColor main")
  else
    dbg("apply: setBgColor missing")
    logToFile("apply: setBgColor missing")
  end

  local okWin, winW, winH = pcall(getMainWindowSize)
  if not okWin or not winW or not winH then
    dbg("apply: getMainWindowSize error")
    logToFile("apply: getMainWindowSize error")
    return
  end
  dbg("apply: getMainWindowSize ok")
  logToFile("apply: getMainWindowSize ok")

  ensureAssets()
  local topPath = borderPath("border_top.png")
  local bottomPath = borderPath("border_bottom.png")
  local leftPath = borderPath("border_left.png")
  local rightPath = borderPath("border_right.png")
  dbg("apply: packageDir=" .. packageDir())
  logToFile("apply: packageDir=" .. packageDir())
  dbg("apply: borders top=" .. topPath .. " bottom=" .. bottomPath .. " left=" .. leftPath .. " right=" .. rightPath)
  logToFile("apply: borders top=" .. topPath .. " bottom=" .. bottomPath .. " left=" .. leftPath .. " right=" .. rightPath)
  if not (io.exists(topPath) and io.exists(bottomPath) and io.exists(leftPath) and io.exists(rightPath)) then
    cecho("&lt;red&gt;DGRGUI_BG: &lt;reset&gt;Missing border image(s)\n")
    logToFile("Missing border image(s)")
    return
  end

  if dgrgui_bg.label then
    dgrgui_bg.label:hide()
  end
  if dgrgui_bg.mask then
    dgrgui_bg.mask:hide()
  end

  dgrgui_bg.panels = dgrgui_bg.panels or {}
  local function ensurePanel(name)
    if not dgrgui_bg.panels[name] then
      dgrgui_bg.panels[name] = Geyser.Label:new({name = name, x = 0, y = 0, width = 0, height = 0})
      if dgrgui_bg.panels[name].setClickthrough then
        dgrgui_bg.panels[name]:setClickthrough(true)
      elseif type(setClickthrough) == "function" then
        setClickthrough(name, true)
      end
    end
    return dgrgui_bg.panels[name]
  end

  local rect = dgrgui_bg.consoleRect or {}
  local conX = rect.x or 0
  local conY = rect.y or 0
  local conW = rect.w or rect.width or 0
  local conH = rect.h or rect.height or 0
  if conW == 0 or conH == 0 then
    dbg("apply: consoleRect missing; continuing with window-only sizing")
    logToFile("apply: consoleRect missing; continuing with window-only sizing")
  else
    dbg("apply: consoleRect " .. conX .. "," .. conY .. " " .. conW .. "x" .. conH)
    logToFile("apply: consoleRect " .. conX .. "," .. conY .. " " .. conW .. "x" .. conH)
  end

  local topH = 200
  local bottomH = 200
  dbg("apply: border sizes topH=" .. topH .. " bottomH=" .. bottomH .. " (left/right disabled)")
  logToFile("apply: border sizes topH=" .. topH .. " bottomH=" .. bottomH .. " (left/right disabled)")

  local top = ensurePanel("DGRGUI_BG_Top")
  top:move(0, 0)
  top:resize(winW, topH)
  top:setStyleSheet([[background-image: url("]] .. topPath .. [["); background-repeat: repeat-x; background-position: center top; background-size: 50% 100%;]])
  top:show()

  local bottom = ensurePanel("DGRGUI_BG_Bottom")
  bottom:move(0, winH - bottomH)
  bottom:resize(winW, bottomH)
  bottom:setStyleSheet([[background-image: url("]] .. bottomPath .. [["); background-repeat: repeat-x; background-position: center bottom; background-size: 50% 100%;]])
  bottom:show()

  local left = ensurePanel("DGRGUI_BG_Left")
  left:hide()

  local right = ensurePanel("DGRGUI_BG_Right")
  right:hide()

  if type(setZOrder) == "function" then
    setZOrder("DGRGUI_BG_Top", "bottom")
    setZOrder("DGRGUI_BG_Bottom", "bottom")
    setZOrder("DGRGUI_BG_Left", "bottom")
    setZOrder("DGRGUI_BG_Right", "bottom")
    setZOrder("main", "top")
  end

  dbg("apply: borders applied window=" .. winW .. "x" .. winH .. " mode=repeat-2x center")
  logToFile("apply: borders applied window=" .. winW .. "x" .. winH .. " mode=repeat-2x center")
end

function dgrgui_bg.hide()
  dgrgui_bg.enabled = false
  if dgrgui_bg.label then
    dgrgui_bg.label:hide()
  end
  dbg("hide: disabled")
end

function dgrgui_bg.show()
  dgrgui_bg.enabled = true
  dgrgui_bg.apply()
end

function dgrgui_bg.toggle()
  if dgrgui_bg.enabled then
    dgrgui_bg.hide()
  else
    dgrgui_bg.show()
  end
end

registerNamedEventHandler("DGRGUI_BG", "DGRGUI_BG_Load", "sysLoadEvent", dgrgui_bg.apply)
registerNamedEventHandler("DGRGUI_BG", "DGRGUI_BG_Resize", "sysWindowResizeEvent", dgrgui_bg.apply)
</script>
      <command />
      <packageName>DGRGUI_BG</packageName>
      <eventHandlerList />
    </Script>
<Script isActive="yes" isFolder="no">
          
        <name>Code</name>
        <script>--[[
========================================================
 EMCO CHAT WINDOW â€” AVAILABLE COMMANDS &amp; FEATURES
========================================================
This system controls your tabbed chat window (EMCO).
All commands begin with:  emco

--------------------------------------------------------
 TAB MANAGEMENT
--------------------------------------------------------
emco addtab &lt;tabname&gt;
  Adds a new tab to the chat window.

emco remtab &lt;tabname&gt;
  Removes an existing tab.

--------------------------------------------------------
 DISPLAY &amp; APPEARANCE
--------------------------------------------------------
emco show
  Shows the EMCO chat window.

emco hide
  Hides the EMCO chat window.

emco lock
  Locks the window so it cannot be moved or resized.

emco unlock
  Unlocks the window so it can be moved/resized again.

emco font &lt;fontname&gt;
  Sets the font used by the chat consoles.

emco fontSize &lt;size&gt;
  Sets the font size for the chat consoles.

emco tabFontSize &lt;size&gt;
  Sets the font size for the tabs (independent of console).

emco addFontSize &lt;size&gt;
  Alias for tabFontSize.

emco color &lt;option&gt; &lt;value&gt;
  Changes colors for tabs and backgrounds.
  Use 'emco color' by itself to see available options.

emco title &lt;new title&gt;
  Sets the title displayed at the top of the chat window.
  Default title: "Tabbed Chat"

--------------------------------------------------------
 MESSAGE DISPLAY OPTIONS
--------------------------------------------------------
emco timestamp &lt;true|false&gt;
  Turns timestamps on or off for messages.

emco blankLine &lt;true|false&gt;
  Inserts (or removes) a blank line between messages.

emco blink &lt;true|false&gt;
  Turns tab blinking on or off for new activity.

--------------------------------------------------------
 NOTIFICATIONS
--------------------------------------------------------
emco notify &lt;tabname&gt;
  Enables OS-level notifications for that tab.

emco unnotify &lt;tabname&gt;
  Disables OS-level notifications for that tab.

--------------------------------------------------------
 GAGGING / FILTERING
--------------------------------------------------------
emco gag &lt;pattern&gt;
  Adds a gag filter (hides matching text).

emco ungag &lt;pattern&gt;
  Removes a gag filter.

emco gaglist
  Shows all currently active gag patterns.

--------------------------------------------------------
 CONFIGURATION
--------------------------------------------------------
emco save
  Saves your current EMCO configuration to disk.

emco load
  Loads your saved EMCO configuration.

emco version
  Displays the current EMCO version and repository information.

emco update
  (Re)installs or updates to the latest EMCO package version.

emco restart
  Restarts the EMCO chat window and reloads defaults.

--------------------------------------------------------
USAGE IN CODE
--------------------------------------------------------
To copy lines from triggers to a tab:
  demonnic.chat:append("TabName")

To send custom messages:
  demonnic.chat:cecho("TabName", "Your message here\n")
  demonnic.chat:decho("TabName", "Your message here\n")
  demonnic.chat:hecho("TabName", "Your message here\n")

Full API documentation:
  https://demonnic.github.io/mdk/current/classes/EMCO.html

========================================================
 End of EMCO Help
========================================================
]]--

local defaultConfig = {activeColor = "black", inactiveColor = "black", activeBorder = "green", activeText = "green", inactiveText = "grey", background = "black", windowBorder = "green", title = "green"}
local emco
do
  local home = getMudletHomeDir():gsub("\\", "/")
  ensureAssets()
  local dir = packageDir()
  local modPath = dir .. "/?.lua"
  local modInit = dir .. "/?/init.lua"
  if not package.path:find(modPath, 1, true) then
    package.path = modPath .. ";" .. package.path
  end
  if not package.path:find(modInit, 1, true) then
    package.path = modInit .. ";" .. package.path
  end
  emco = require("emco")
end
emco.cmdLineStyleSheet = nil
demonnic = demonnic or {}
demonnic.helpers = demonnic.helpers or {}
demonnic.config = demonnic.config or defaultConfig
local baseStyle = Geyser.StyleSheet:new(f [[
  border-width: 2px; 
  border-style: solid; 
]])
local activeStyle = Geyser.StyleSheet:new(f [[
  border-color: {demonnic.config.activeBorder};
  background-color: {demonnic.config.activeColor};
]], baseStyle)
local inactiveStyle = Geyser.StyleSheet:new(f [[
  border-color: {demonnic.config.inactiveColor};
  background-color: {demonnic.config.inactiveColor};
]], baseStyle)
local adjLabelStyle = Geyser.StyleSheet:new(f[[
  background-color: rgba(0,0,0,100%);
  border: 4px double;
  border-color: {demonnic.config.windowBorder};
  border-radius: 4px;]])

local default_constraints = {name = "EMCOPrebuiltChatContainer", x = "-25%", y = "-60%", width = "25%", height = "60%", titleText = "Tabbed Chat"}

local chatEMCO = demonnic.chat
local EMCOfilename = getMudletHomeDir() .. "/EMCO/EMCOPrebuiltChat.lua"
local confFile = getMudletHomeDir() .. "/EMCO/EMCOPrebuiltExtraOptions.lua"

function demonnic.helpers.echo(msg)
  msg = msg or ""
  cecho(f "&lt;green&gt;EMCO Chat: &lt;reset&gt;{msg}\n")
end

function demonnic.helpers.resetToDefaults()
  default_constraints.adjLabelstyle = adjLabelStyle:getCSS()
  demonnic.container = demonnic.container or Adjustable.Container:new(default_constraints)
  demonnic.config = defaultConfig
  demonnic.chat = emco:new({
    name = "EMCOPrebuiltChat",
    x = 0,
    y = 0,
    height = "100%",
    width = "100%",
    consoles = {"All", "Program", "OOC", "RP", "Whisper", "Group", "Game"},
    allTab = true,
    allTabName = "All",
    blankLine = true,
    blink = true,
    bufferSize = 10000,
    deleteLines = 500,
    timestamp = true,
    fontSize = 14,
    tabFontSize = 16,
    font = "Ubuntu Mono",
    consoleColor = demonnic.config.background,
    activeTabCSS = activeStyle:getCSS(),
    inactiveTabCSS = inactiveStyle:getCSS(),
    activeTabFGColor = demonnic.config.activeText,
    inactiveTabFGColor = demonnic.config.inactiveText,
    gap = 3,
    commandLine = true,
  }, demonnic.container)
  chatEMCO = demonnic.chat
  demonnic.helpers.retheme()
end

function demonnic.helpers.retheme()
  activeStyle:set("background-color", demonnic.config.activeColor)
  activeStyle:set("border-color", demonnic.config.activeBorder)
  inactiveStyle:set("background-color", demonnic.config.inactiveColor)
  inactiveStyle:set("border-color", demonnic.config.inactiveColor)
  adjLabelStyle:set("border-color", demonnic.config.windowBorder)
  local als = adjLabelStyle:getCSS()
  demonnic.container.adjLabelstyle = als
  demonnic.container.adjLabel:setStyleSheet(als)
  demonnic.container:setTitle(demonnic.container.titleText, demonnic.config.title)
  chatEMCO.activeTabCSS = activeStyle:getCSS()
  chatEMCO.inactiveTabCSS = inactiveStyle:getCSS()
  chatEMCO:setActiveTabFGColor(demonnic.config.activeText)
  chatEMCO:setInactiveTabFGColor(demonnic.config.inactiveText)
  chatEMCO:setConsoleColor(demonnic.config.background)
  chatEMCO:switchTab(chatEMCO.currentTab)
end

function demonnic.helpers.setConfig(cfg, val)
  local validOptions = table.keys(demonnic.config)
  if not table.contains(validOptions, cfg) then
    return nil, f"invalid option: valid options are {table.concat(validOptions, ', ')}"
  end
  demonnic.config[cfg] = val
  demonnic.helpers.retheme()
  return true
end

function demonnic.helpers.save()
  chatEMCO:save()
  table.save(confFile, demonnic.config)
  demonnic.container:save()
end

function demonnic.helpers.load()
  if io.exists(confFile) then
    local conf = {}
    table.load(confFile, conf)
    demonnic.config = table.update(demonnic.config, conf)
    for option, value in pairs(defaultConfig) do
      demonnic.config[option] = demonnic.config[option] or value
    end
  end
  if io.exists(EMCOfilename) then
    chatEMCO:hide()
    chatEMCO:load()
    chatEMCO:show()
  end
  demonnic.container:load()
  demonnic.helpers.retheme()
end

local function startup()
  demonnic.helpers.resetToDefaults()
  demonnic.helpers.load()
end

registerNamedEventHandler("demonnicEMCO", "EMCOprebuilt startup", "sysLoadEvent", startup)
</script>
          
        <packageName />
        
        <eventHandlerList>
</eventHandlerList>
        
      </Script>
<Script isActive="yes" isFolder="no"><name>README</name><script>--[[
EMCO Chat Package README

Author: Demonnic
Contributor: WizzyDizzy

Important
- Do not add or change anything inside the EMCOChat package folders.
- EMCO updates overwrite package contents and will delete custom changes.
- Put your custom triggers/aliases/scripts outside EMCOChat, or in a separate custom package.

Installation
- lua installPackage("https://github.com/dragonsgatereborn/DGR-Mudlet-GUI/releases/latest/download/DGRGUI_BG.mpackage")
- emco update (updates from GitHub)

Usage
- demonnic.chat:append("TabName") to send lines to a tab
- demonnic.chat:cecho("TabName", "message\n") for custom output

Available aliases
- emco addtab &lt;tabname&gt;
- emco blankLine &lt;true|false&gt;
- emco blink &lt;true|false&gt;
- emco color &lt;option&gt; &lt;value&gt;
- emco font &lt;fontname&gt;
- emco fontSize &lt;size&gt;
- emco tabFontSize &lt;size&gt;
- emco addFontSize &lt;size&gt;
- emco gag &lt;pattern&gt;
- emco gaglist
- emco hide
- emco load
- emco lock
- emco notify &lt;tabName&gt;
- emco remtab &lt;tabname&gt;
- emco save
- emco show
- emco timestamp &lt;true|false&gt;
- emco title &lt;new title&gt;
- emco unlock
- emco ungag &lt;pattern&gt;
- emco unnotify &lt;tabName&gt;
- emco update
- emco restart
- emco version

Repository
- https://github.com/dragonsgatereborn/DGR-Mudlet-GUI
--]]
</script></Script>
  </ScriptPackage>
  <AliasPackage>
<Alias isActive="yes" isFolder="no">
          
        <name>emco</name>
        <script>local valid_options = {"font", "fontSize", "tabFontSize", "addFontSize", "blink", "blankLine", "timestamp", "save", "load", "show", "hide"}
local valid_options_string = table.concat(valid_options, ", ")
local option = matches[2]
local value = matches[3]
local lecho = demonnic.helpers.echo
if not table.contains(valid_options, option) then
  lecho("Tried to change a config value that does not exist: valid options are " .. valid_options_string)
  return
end
local chatEMCO = demonnic.chat

if option == "save" then
  demonnic.helpers.save()
  lecho("Options saved")
elseif option == "load" then
  demonnic.helpers.load()
  lecho("Options loaded")
elseif option == "show" then
  demonnic.container:show()
elseif option == "hide" then
  demonnic.container:hide()
else
  if value == nil then
    lecho("You need to provide a value when trying to configure things")
    return
  end
  if option == "font" then
    local validFont = table.contains(getAvailableFonts(), value)
    if not validFont then
      lecho("You tried to set the font to one that Mudlet doesn't recognize. This will not do.")
    else
      chatEMCO:setFont(value)
    end
  elseif table.contains({"blink", "blankLine", "timestamp"}, option) then
    value = chatEMCO:fuzzyBoolean(value)
    if value then
      if option == "timestamp" then
        chatEMCO:enableTimestamp()
      elseif option == "blankLine" then
        chatEMCO:enableBlankLine()
      elseif option == "blink" then
        chatEMCO:enableBlink()
      elseif option == "commandLine" then
        chatEMCO:enableCommandLine()
      end
    else
      if option == "timestamp" then
        chatEMCO:disableTimestamp()
      elseif option == "blankLine" then
        chatEMCO:disableBlankLine()
      elseif option == "blink" then
        chatEMCO:disableBlink()
      elseif option == "commandLine" then
        chatEMCO:disableCommandLine()
      end
    end
  elseif option == "tabFontSize" or option == "addFontSize" then
    value = tonumber(value)
    if value then
      chatEMCO:setTabFontSize(value)
      lecho("Tab font size set to " .. value)
    else
      lecho("You tried to set the tabFontSize to a nonnumber. Attempted: " .. matches[3])
    end
  else
    value = tonumber(value)
    if value then
      chatEMCO:setFontSize(value)
    else
      lecho("You tried to set the fontSize to a nonnumber. Attempted: " .. matches[3])
    end
  end
end
</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco (save|load|font|fontSize|tabFontSize|addFontSize|blink|blankLine|timestamp|show|hide)(?: (.+))?$</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco gag</name>
        <script>local success = demonnic.chat:addGag(matches[2])
local echo = demonnic.helpers.echo
if success then
  echo(f"Successfully added '{matches[2]}' as a gag pattern")
  return
end
echo(f"Unable to add '{matches[2]}' as a gag pattern, this is usually because it's already added.")</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco gag (.+)</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco ungag</name>
        <script>local success = demonnic.chat:removeGag(matches[2])
local echo = demonnic.helpers.echo
if success then
  echo(f"Successfully removed '{matches[2]}' as a gag pattern")
  return
end
echo(f"Unable to remove '{matches[2]}' as a gag pattern, this is usually because it hasn't been set.")</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco ungag (.+)</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco gaglist</name>
        <script>local lecho = demonnic.helpers.echo
local gaggedLines = table.keys(demonnic.chat.gags)
table.sort(gaggedLines)

lecho("&lt;orange&gt;Gagging report. Remember these are Lua patterns, not regex")
lecho()
lecho("&lt;orange&gt;Gagged lines")
for _,pattern in ipairs(gaggedLines) do
  lecho("  &lt;purple&gt;" .. pattern)
end
</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco gaglist$</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco notify</name>
        <script>local tabName = matches[2]:title()
local echo = demonnic.helpers.echo
local ok = demonnic.chat:addNotifyTab(tabName)

if ok then
  echo(f"Enabled OS notifications for tab {tabName}")
elseif ok == false then
  echo(f"Tab {tabName} already had notifications enabled!")
else
  echo(f"Tab {tabName} does not exist")
end</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco notify (.*)</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco unnotify</name>
        <script>local tabName = matches[2]:title()
local echo = demonnic.helpers.echo
local ok = demonnic.chat:removeNotifyTab(tabName)

if ok then
  echo(f"Disabled OS notifications for tab {tabName}")
elseif ok == false then
  echo(f"Tab {tabName} already had notifications disabled!")
else
  echo(f"Tab {tabName} does not exist")
end</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco unnotify (.*)</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco addtab</name>
        <script>local tabName = matches[2]
local pos = tonumber(matches[3])
local echo = demonnic.helpers.echo
local chatEMCO = demonnic.chat

if table.contains(chatEMCO.consoles, tabName) then
  echo(f"{tabName} already exists!")
  return
end
chatEMCO:addTab(tabName, pos)</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco addtab (\w+)( \d+)?$</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco remtab</name>
        <script>local tabName = matches[2]
local echo = demonnic.helpers.echo
local chatEMCO = demonnic.chat
local tabList = chatEMCO.consoles
if not table.contains(tabList, tabName) then
  echo(f"{tabName} does not exist to remove. Current tabs are: {table.concat(tabList, ', '}")
  return
end
chatEMCO:removeTab(tabName)</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco remtab (.+)</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco color</name>
        <script>local echo = demonnic.helpers.echo
local ok, err = demonnic.helpers.setConfig(matches[2], matches[3])

if not ok then
  echo(err)
  return
end
echo(f"Set color for {matches[2]} to {matches[3]}")</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco color (\w+) (.+)</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco color usage</name>
        <script>local echo = demonnic.helpers.echo
local validOptions = table.keys(demonnic.config)
table.sort(validOptions)
local validOptionsString = table.concat(validOptions, ", ")
echo("Usage information for changing emco colors")
echo()
echo("emco color &lt;option&gt; &lt;color&gt;")
echo("Color can be anything you would use in CSS, such as 'rgb(128,128,128)', '#888888', or 'grey'")
echo("examples:")
echo("  * emco color activeBorder goldenrod")
echo("    * changes the border around the active tab to goldenrod")
echo("  * emco color activeColor #00ff00")
echo("    * changes the color of the active tab to green")
echo()
echo("Valid options are " .. validOptionsString)
echo("Remember to use 'emco save' to make your changes permanent, or 'emco load' to undo them and reset back to what you previously saved.")</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco color$</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco usage</name>
        <script>local echo = demonnic.helpers.echo
local aliases = {
  ["emco save"] = "saves your config to disk",
  ["emco load"] = "loads your config from disk",
  ["emco addtab &lt;tabname&gt;"] = "adds a tab to your EMCO",
  ["emco remtab &lt;tabname&gt;"] = "removes a tab from your EMCO",
  ["emco fontSize"] = "set the font size for the consoles",
  ["emco tabFontSize"] = "set the font size for the tabs",
  ["emco addFontSize"] = "alias for tabFontSize",
  ["emco font"] = "set the font to use for the consoles",
  ["emco blink &lt;true|false&gt;"] = "turn blinking on/off",
  ["emco blankLine &lt;true|false&gt;"] = "turn inserting a blank line between messages on/off",
  ["emco timestamp &lt;true|false&gt;"] = "turn timestamps on/off",
  ["emco show"] = "show the EMCO",
  ["emco hide"] = "hide the EMCO",
  ["emco gaglist"] = "prints out the list of gag patterns",
  ["emco gag &lt;pattern&gt;"] = "add a gag pattern",
  ["emco ungag &lt;pattern&gt;"] = "remove a gag pattern",
  ["emco notify &lt;tabName&gt;"] = "turn on OS notifications for tabName",
  ["emco unnotify &lt;tabName&gt;"] = "turn off OS notifications for tabName",
  ["emco color &lt;option&gt; &lt;value&gt;"] = "used to change the colors for the active/inactive tab, and the background color for the consoles. 'emco color' with no options will print out available options",
  ["emco version"] = "display the current EMCO version and repository information",
  ["emco update"] = "(re)install the latest version of the package",
  ["emco restart"] = "restart the EMCO chat window and reload defaults",
}

echo("\nAvailable aliases for the prebuilt EMCO package")
echo()
for name, desc in spairs(aliases) do
  echo(f"* {name}")
  echo(f"  * {desc}")
end
</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco( usage)?$</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco update</name>
        <script>local currentVersion = "0.0.2"
local repoUrl = "https://github.com/dragonsgatereborn/DGR-Mudlet-GUI"
local apiUrl = "https://api.github.com/repos/dragonsgatereborn/DGR-Mudlet-GUI/releases/latest"
local packageUrl = repoUrl .. "/releases/latest/download/DGRGUI_BG.mpackage"

local function installLatest(latestTag)
  uninstallPackage("DGRGUI_BG")
  installPackage(packageUrl)
  cecho("&lt;green&gt;EMCO Chat: &lt;reset&gt;Update complete! Package installed from:\n")
  cecho("&lt;green&gt;EMCO Chat: &lt;reset&gt;" .. packageUrl .. "\n")
end

cecho("&lt;green&gt;EMCO Chat: &lt;reset&gt;Current version: " .. currentVersion .. "\n")
cecho("&lt;green&gt;EMCO Chat: &lt;reset&gt;Updating from " .. repoUrl .. "\n")
cecho("&lt;green&gt;EMCO Chat: &lt;reset&gt;Fetching latest version...\n")

if getHTTP then
  local completed = false
  tempTimer(8, function()
    if not completed then
      completed = true
      cecho("&lt;green&gt;EMCO Chat: &lt;reset&gt;Latest version: unknown (timed out). Installing latest.\n")
      installLatest("")
    end
  end)
  getHTTP(apiUrl, {}, function(body, code)
    if completed then return end
    completed = true
    if code and tonumber(code) ~= 200 then
      cecho("&lt;green&gt;EMCO Chat: &lt;reset&gt;Latest version: unknown (HTTP " .. tostring(code) .. "). Installing latest.\n")
      installLatest("")
      return
    end
    local tag = body and body:match('"tag_name"%s*:%s*"([^"]+)"') or ""
    if tag == "" then
      cecho("&lt;green&gt;EMCO Chat: &lt;reset&gt;Latest version: unknown (invalid response). Installing latest.\n")
      installLatest("")
      return
    end
    cecho("&lt;green&gt;EMCO Chat: &lt;reset&gt;Latest version: " .. tag .. "\n")
    local currentTag = currentVersion
    if tag == currentTag or tag == ("v" .. currentTag) then
      cecho("&lt;green&gt;EMCO Chat: &lt;reset&gt;Already up to date.\n")
      return
    end
    cecho("&lt;green&gt;EMCO Chat: &lt;reset&gt;Updating to " .. tag .. "\n")
    installLatest(tag)
  end)
else
  cecho("&lt;green&gt;EMCO Chat: &lt;reset&gt;Latest version: unknown (getHTTP unavailable). Installing latest.\n")
  installLatest("")
end
</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco update$</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco title</name>
        <script>local title = matches[2]
if title == "clear" then
  title = ""
end
demonnic.container:setTitle(title)</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco title (.+)</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco lock</name>
        <script>demonnic.container:lockContainer()</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco lock$</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no">
          
        <name>emco unlock</name>
        <script>demonnic.container:unlockContainer()</script>
          
        <command />
          
        <packageName />
          
        <regex>^emco unlock$</regex>
        
      </Alias>
<Alias isActive="yes" isFolder="no"><name>emco version</name><script>local version = "0.0.2"
local repo = "https://github.com/dragonsgatereborn/DGR-Mudlet-GUI"

cecho("&lt;green&gt;EMCO Chat Package\n")
cecho("&lt;green&gt;Version: &lt;yellow&gt;" .. version .. "\n")
cecho("&lt;green&gt;Repository: &lt;cyan&gt;dragonsgatereborn/DGR-Mudlet-GUI\n")
cecho("&lt;green&gt;GitHub: &lt;cyan&gt;" .. repo .. "\n")
cecho("&lt;white&gt;Use &lt;green&gt;emco update&lt;white&gt; to check for updates.\n")
</script><command /><packageName /><regex>^emco version$</regex></Alias>
<Alias isActive="yes" isFolder="no"><name>README</name><script>--[[
EMCO Chat Package README

Author: Demonnic
Contributor: WizzyDizzy

Important
- Do not add or change anything inside the EMCOChat package folders.
- EMCO updates overwrite package contents and will delete custom changes.
- Put your custom triggers/aliases/scripts outside EMCOChat, or in a separate custom package.

Install
- lua installPackage("https://github.com/dragonsgatereborn/DGR-Mudlet-GUI/releases/latest/download/DGRGUI_BG.mpackage")
- emco update (updates from GitHub)

Aliases
- emco addtab &lt;tabname&gt;
- emco blankLine &lt;true|false&gt;
- emco blink &lt;true|false&gt;
- emco color &lt;option&gt; &lt;value&gt;
- emco font &lt;fontname&gt;
- emco fontSize &lt;size&gt;
- emco tabFontSize &lt;size&gt;
- emco addFontSize &lt;size&gt;
- emco gag &lt;pattern&gt;
- emco gaglist
- emco hide
- emco load
- emco lock
- emco notify &lt;tabName&gt;
- emco remtab &lt;tabname&gt;
- emco save
- emco show
- emco timestamp &lt;true|false&gt;
- emco title &lt;new title&gt;
- emco unlock
- emco ungag &lt;pattern&gt;
- emco unnotify &lt;tabName&gt;
- emco update
- emco restart
- emco version

Repository
- https://github.com/dragonsgatereborn/DGR-Mudlet-GUI
--]]
</script><command /><packageName /><regex>^__EMCO_README__$</regex></Alias>
<Alias isActive="yes" isFolder="no"><name>emco restart</name><script>local echo = demonnic.helpers.echo

if demonnic.container then
  if demonnic.container.hide then
    demonnic.container:hide()
  end
  if demonnic.container.close then
    demonnic.container:close()
  end
  if demonnic.container.destroy then
    demonnic.container:destroy()
  end
end

demonnic.container = nil
demonnic.chat = nil
collectgarbage("collect")

demonnic.helpers.resetToDefaults()
echo("Restarted EMCO chat window.")
</script><command /><packageName /><regex>^emco restart$</regex></Alias>
  </AliasPackage>
  <TimerPackage>
  </TimerPackage>
  <TriggerPackage>
<Trigger isActive="yes" isFolder="no"><name>README</name><script>--[[
EMCO Chat Package README (Triggers)

Author: Demonnic
Contributor: WizzyDizzy

Important
- Do not add or change anything inside the EMCOChat package folders.
- EMCO updates overwrite package contents and will delete custom changes.
- Put your custom triggers outside EMCOChat, or in a separate custom package.

Repository
- https://github.com/dragonsgatereborn/DGR-Mudlet-GUI
--]]
</script><command /><packageName /><regexCodeList /><regexCodePropertyList /></Trigger>
<Trigger isActive="yes" isFolder="no"><name>ALL</name><script>--[[
Example trigger for ALL messages
Pattern: ^\[ALL\]
--]]

demonnic.chat:append("All")
</script><command /><packageName /><regexCodeList><string>^\[ALL\]</string></regexCodeList><regexCodePropertyList><integer>1</integer></regexCodePropertyList></Trigger>
<Trigger isActive="yes" isFolder="no"><name>PROGRAM</name><script>--[[
Example trigger for PROGRAM messages
Pattern: ^\[PROGRAM\]
--]]

demonnic.chat:append("Program")
</script><command /><packageName /><regexCodeList><string>^\[PROGRAM\]</string></regexCodeList><regexCodePropertyList><integer>1</integer></regexCodePropertyList></Trigger>
<Trigger isActive="yes" isFolder="no"><name>OOC</name><script>--[[
Example trigger for OOC messages
Pattern: ^\[OOC\]
--]]

demonnic.chat:append("OOC")
</script><command /><packageName /><regexCodeList><string>^\[OOC\]</string></regexCodeList><regexCodePropertyList><integer>1</integer></regexCodePropertyList></Trigger>
<Trigger isActive="yes" isFolder="no"><name>RP</name><script>--[[
Example trigger for RP messages
Pattern: ^\[RP\]
--]]

demonnic.chat:append("RP")
</script><command /><packageName /><regexCodeList><string>^\[RP\]</string></regexCodeList><regexCodePropertyList><integer>1</integer></regexCodePropertyList></Trigger>
<Trigger isActive="yes" isFolder="no"><name>WHISPER</name><script>--[[
Example trigger for WHISPER messages
Pattern: ^\[WHISPER\]
--]]

demonnic.chat:append("Whisper")
</script><command /><packageName /><regexCodeList><string>^\[WHISPER\]</string></regexCodeList><regexCodePropertyList><integer>1</integer></regexCodePropertyList></Trigger>
<Trigger isActive="yes" isFolder="no"><name>GROUP</name><script>--[[
Example trigger for GROUP messages
Pattern: ^\[GROUP\]
--]]

demonnic.chat:append("Group")
</script><command /><packageName /><regexCodeList><string>^\[GROUP\]</string></regexCodeList><regexCodePropertyList><integer>1</integer></regexCodePropertyList></Trigger>
<Trigger isActive="yes" isFolder="no"><name>GAME</name><script>--[[
Example trigger for GAME messages
Pattern: ^\[GAME\]
--]]

demonnic.chat:append("Game")
</script><command /><packageName /><regexCodeList><string>^\[GAME\]</string></regexCodeList><regexCodePropertyList><integer>1</integer></regexCodePropertyList></Trigger>
  </TriggerPackage>
  <KeyPackage>
  </KeyPackage>
</MudletPackage>
